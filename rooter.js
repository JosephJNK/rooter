// Generated by CoffeeScript 1.3.3
(function() {
  var hash, hashTimer, rooter;

  hash = {
    listeners: [],
    listen: function(fn) {
      return rooter.hash.listeners.push(fn);
    },
    trigger: function(newHash) {
      if (newHash == null) {
        newHash = rooter.hash.value();
      }
      console.log("trigger called with hash " + newHash);
      if (newHash === "") {
        newHash = "/";
      }
      return hash.pendingTeardown(function() {
        var fn, _i, _len, _ref;
        hash.pendingTeardown = function(cb) {
          return cb();
        };
        console.log("about to call a listener function");
        _ref = rooter.hash.listeners;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          fn(newHash);
        }
      });
    },
    value: function(newHash) {
      if (newHash) {
        window.location.hash = newHash;
      }
      return window.location.hash.replace('#', '');
    }
  };

  hashTimer = {
    listeners: [],
    listen: function(fn) {
      return rooter.hash.listeners.push(fn);
    },
    trigger: function(hash) {
      var fn, _i, _len, _ref;
      if (hash == null) {
        hash = rooter.hash.value();
      }
      if (hash === "") {
        hash = "/";
      }
      console.log("hashTimer got triggered");
      _ref = rooter.hash.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        fn(hash);
      }
    },
    value: function(newHash) {
      if (newHash) {
        rooter.hash.lastHash = newHash;
        window.location.hash = newHash;
      }
      return window.location.hash.replace('#', '');
    },
    lastHash: null,
    check: function() {
      var currHash;
      currHash = rooter.hash.value();
      if (currHash !== rooter.hash.lastHash) {
        rooter.hash.lastHash = currHash;
        rooter.hash.trigger(currHash);
      }
      setTimeout(rooter.hash.check, 100);
    }
  };

  rooter = {
    init: function() {
      console.log("routes", rooter.routes);
      rooter.hash.pendingTeardown = function(cb) {
        return cb();
      };
      rooter.hash.listen(rooter.test);
      if (rooter.hash.check) {
        return rooter.hash.check();
      }
      return rooter.hash.trigger();
    },
    routes: {},
    route: function(expr, setup, teardown) {
      var pattern;
      pattern = "^" + expr + "$";
      pattern = pattern.replace(/([?=,\/])/g, '\\$1').replace(/:([\w\d]+)/g, '([^/]*)');
      rooter.routes[expr] = {
        name: expr,
        paramNames: expr.match(/:([\w\d]+)/g),
        pattern: new RegExp(pattern),
        setup: setup,
        teardown: teardown ? teardown : function(cb) {
          return cb();
        },
        beforeFilters: []
      };
    },
    runBeforeFilters: function(destination, routeInput, cb) {
      var filters, runFilters;
      console.log("about to run before filters for " + destination.name);
      runFilters = function(filterArray) {
        console.log("destination is currently " + destination.name);
        if (filterArray.length === 0) {
          console.log("done running filters, returning");
          return cb(null);
        }
        return filterArray.shift()(routeInput, function(err) {
          console.log("ran a filter");
          console.log("it returned: " + err);
          if (err) {
            return cb(err);
          }
          console.log("gonna run another filter");
          return runFilters(filterArray);
        });
      };
      filters = destination.beforeFilters.slice(0);
      return runFilters(filters);
    },
    test: function(attemptedHash) {
      var args, destination, idx, matches, name, routeInput, url, _i, _len, _ref, _ref1;
      _ref = rooter.routes;
      for (url in _ref) {
        destination = _ref[url];
        if (matches = destination.pattern.exec(attemptedHash)) {
          routeInput = {};
          if (destination.paramNames) {
            args = matches.slice(1);
            _ref1 = destination.paramNames;
            for (idx = _i = 0, _len = _ref1.length; _i < _len; idx = ++_i) {
              name = _ref1[idx];
              routeInput[name.substring(1)] = args[idx];
            }
          }
          console.log("routes before calling filters", rooter.routes);
          console.log("destination before calling filters: " + destination.name);
          rooter.runBeforeFilters(destination, routeInput, function(err) {
            console.log("routes after calling filters", rooter.routes);
            console.log("destination after calling filters: " + destination.name);
            console.log("filters returned err: " + err);
            if (!err) {
              console.log("passed filters, about to teardown");
              hash.pendingTeardown = destination.teardown;
              console.log("teardown complete");
              destination.setup(routeInput);
              return console.log("setup complete");
            }
          });
        }
      }
    },
    addBeforeFilter: function(expr, filter) {
      if (!rooter.routes[expr]) {
        return;
      }
      return rooter.routes[expr].beforeFilters.push(filter);
    }
  };

  if (typeof window.onhashchange !== 'undefined') {
    rooter.hash = hash;
    window.onhashchange = function() {
      return rooter.hash.trigger(rooter.hash.value());
    };
  } else {
    rooter.hash = hashTimer;
    setTimeout(rooter.hash.check, 100);
  }

  window.rooter = rooter;

}).call(this);
